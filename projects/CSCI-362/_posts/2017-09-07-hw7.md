---
layout: post
title: "HW7: Reflections"
description: A response to various readings regarding software specifications and testing.
date: 2017-09-07 10:00:00 -5EST
category: CSCI-362
---

## **Readings**
* <a href="https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two" target="_blank">The Magical Number Seven, Plus or Minus Two</a>
* <a href="http://stono.cs.cofc.edu/~bowring/classes/csci%20362/docs/rfid-tire-pressure-2010-002-tpms.pdf" target="_blank">Security and Privacy Vulnerabilities of In-Car Wireless Networks: A Tire Pressure Monitoring System Case Study</a>
* <a href="https://www.markey.senate.gov/imo/media/doc/SPY%20Car%20legislation.pdf" target="_blank">SPY Car Act of 2015</a>
* <a href="https://www.simple-talk.com/cloud/development/planning-for-failure-in-cloud-applications/" target="_blank">Planning for Failure in Cloud Applications</a>
* <a href="http://www.agiledata.org/essays/tdd.html" target="_blank">Introduction to Test Driven Development (TDD)</a>
* Chapter 4 of <a href="http://iansommerville.com/software-engineering-book/" target="_blank"><em>Software Engineering</em></a>

## **Response**
&nbsp;&nbsp;&nbsp;&nbsp;As I discussed in <a href="/projects/csci-362/2017/09/04/hw5.html" target="_blank">my last reflections post</a>, one of the greatest hurdles we face as software developers is our will to follow good practices and procedures when designing, developing, testing, and maintaining our software. In Chapter 4 of <a href="http://iansommerville.com/software-engineering-book/" target="_blank"><em>Software Engineering</em></a> Ian Sommerville discusses, in great detail, extensive design processes before ever even considering beginning to build a piece of software. He discusses the differences between functional and nonfunctional requirements, and using them to develop strctured use case scenario and specifications when designing a software system. When we don't give enough thought and effort when drafting our specifications, often times we may overlook critical flaws or missing components. Thorough design and specifications are an essential part of developing a reliable and secure application.

&nbsp;&nbsp;&nbsp;&nbsp;As an example, consider the readings regarding tire pressure monitoring systems. These systems have become an essential part - alongside countless other technical innovations - of modern automobiles which strive to provide detailed information about the condition of the automobile to those in it. However, despite the wonderful features that such systems have provided to automobile owners, we see that critical security concerns had not been properly addressed when designing them (leading to the SPY Car Act of 2015). The lack of consideration for security left many automobiles vulnerable to malicious attackers. And they're not alone in this. With the rise of the Internet of Things (IoT), countless devices that, in the past, we may have never considered would be part of an automated system, are now being automated and connected via networking. I've read / heard several stories about simple devices, such as electronically-voiced Teddy Bears and baby monitors (among the simplest cases), being hacked into.

&nbsp;&nbsp;&nbsp;&nbsp;The other problem that we face is, what happens when these systems fail? Autonomous systems (in terms of, for example, simple devices owned and maintained by civilians) seem to often disregard the case where they fail. When home automation or other IoT devices fail and their owners don't have the know-how to fix them is a flaw in the design process by the manufacturer. Along the same lines, in the case of a modern car with the many fancy gadgets that they include now (I don't have one, so this is based largely on secondary sources), what happens when their autonomous systems fail? Are users given adequate warnings in those scenarios, or are they left completely in the dark? Do they have some way to reboot or repair the systems? These are questions that seem to often get overlooked when designing personal devices, let alone larger, centralized systems.

&nbsp;&nbsp;&nbsp;&nbsp;And finally, as I discussed in my previous reflections post, there's testing. Everyone dreads testing, because it's tedious, monotonous, and far less creative and intuitive (generally) than building a software itself. But it's a necessary part of the process to ensure the safety, security, and reliability of your system. To this regard, I think the idea of the "Magical Number Seven" is rather interesting. Consider this scenario. A developer is working on a larger portion of an application. As they develop, they decide that they will wait to write tests until after they finish development completely, and just remember what cases they need to test. They finish their work and start testing, but as they go, they struggle to think of the test cases from before. They tried to keep track of too many things in their mind at once, and as a result they lost that information. Now, the test suite for the software has far less coverage than it would have had they used Test Driven Development (TDD). It's another interesting consideration about our struggle to follow best practices and how our bad decisions will leave a lasting effect on the software we build.
