---
layout: blog/post
title: "HW12: Mythical Man Month"
description: A response to Chapters 1-4 of <em>The Mythical Man-Month</em> by Fred Brooks.
date: 2017-09-26 10:00:00 -5EST
category: csci_362_blog
---

### Reading
<a href="http://stono.cs.cofc.edu/~bowring/classes/csis%20602/docs/The.Mythical.Man.Month.F.Brooks.pdf" target="_blank"><em>The Mythical Man-Month</em></a>

### Response
&nbsp;&nbsp;&nbsp;&nbsp;From my personal experiences as a Software Developer so far, I find myself in some ways agreeing with Brooks's notion of the "Mythical Man Month", but in other ways, fervently disagreeing as well. On the one hand, I've experienced the futility of having a larger team. As a team grows, there are (seemingly) always going to be the group of developers who are working extra to make up for the second group of developers who do next to nothing. There are developers who abide by code, style, and convention standards, while others couldn't care in the least. And there are the developers who rush to finish as much as possible while sacrificing quality and care of work, while others develop so inefficiently (generally due to lack of work) that they often hold up the development or testing processes of other members of the team or the system as a whole.

&nbsp;&nbsp;&nbsp;&nbsp;Despite this, having more people on a team is not always a bad thing. There are certain systems which are simply too big to not have a large team, and there are certain scenarios where more people being brought onto a project to help finish it is more beneficial than not. The team that I'm currently interning for consists of only 9 developers - 3 of which are interns. The primary application that we're responsible for, SPARCRequest, would not be considered particularly large by commercial standards, but it is reasonably large and often has very complex logic and requirements. For our small team, at times we're very busy with continuous requests for new features, bug fixes, or refactors, and at times things are slow, giving us a break of sorts, generally towards the end of a release / beginning of a new release cycle.

&nbsp;&nbsp;&nbsp;&nbsp;But even within our small team, disorganization and inconsistency is rampant. Like Brooks says, these things are a natural part of the team process. But I would argue that we can overcome these obstacles by enforcing stricter organization and standards within the team - holding one another accountable for our productivity and adherence to standards. Within a larger team, we do this by creating subteams and subteams within subteams to work together to tackle sections at a time. But doing this alone isn't enough, because within one team will exist inconsistencies with the work of another team. There has to be an overarching set of standards for design, development, styling, etc. that have to be agreed upon and enforced by all members of the development team. And when these standards are not met, it's our job to remind others and remind them of what needs to be done.

&nbsp;&nbsp;&nbsp;&nbsp;But even if a team manages to find a solid, stable method to organize their team, goals, and standards, that doesn't mean that there won't be problems. Every developer has, at some point or another, run into a problem that they spend way too much time looking at. Confused, frustrated, and exhausted, they may slow down pace and become unable to focus on and complete the task before them. I've seen this firsthand, and probably experienced it too. You can easily get lost within your work, especially if you have spent a week or more in it. You forget what you've done, what needs to be done, and everything can become an overwhelming stress nightmare. When this happens, it's important to have others to back you up. You have to be willing to ask for help, but more importantly, you need to be able to get help when you need it. Having more team members gives you this opportunity, too.

&nbsp;&nbsp;&nbsp;&nbsp;In the end, I think there is a trade off between labor, time, and cost that is virtually impossible to make a realistic expectation of beforehand. There are pros to having more developers, but also cons to having too many. You don't want to over-work the few you have, but you don't want to waste resources on the many who don't produce. I think in some ways Brooks is right in his perspectives of these trade offs, but in many other ways his arguments are deeply flawed from having worked in a different time with different processes and resources. It seems almost like an impossible expectation to expect to fit within budget, deadlines, and achieving full specifications. It's a lot to ask for from a process so complex and building a software system. Can we do better? Yes. But to a point, we have to realize that, in anything, there are trade offs to make. Rarely will you meet a goal 100%.
